{
    "collab_server" : "",
    "contents" : "#' Kernel Canonical Correlation Analysis\n#'\n#' @description Compute the kernel canonical correlations between two data matrices\n#'\n#' @importFrom kernlab inchol()\n#' @importFrom geigen geigen()\n#'\n#' @param x1 The data set containing n samples and p features\n#' @param x2 The data set containing n samples and q features\n#' @param ktyp1 The kernel for the data set x1 (The default value is \"rbfdot\".)\n#' @param ktyp2 The kernel for the data set x2 (The default value is \"rbfdot\".)\n#' @param kpar1 The list of kernel parameters for kernel 1\n#' @param kpar2 The list of kernel parameters for kernel 1\n#' @param reg The regularization parameter (The default is 1e-5.)\n#' @param ...\n#' @details The incomplete Cholesky decomposition is calculated by inchol() from kernlab. The details of choosing the kernel function and setting the kernel parameters is seen in \\url{http://finzi.psych.upenn.edu/library/kernlab/html/inchol.html}\n#'\n#' @return cor The kernel canconical correlation between x1 and x2, which is the first canonical correlation between projections of x1 and x2\n#' @return latent1 The latent variable, which is the nonlinear projection of x1 in the kernel feature space\n#' @return latent2 The latent variable, which is the nonlinear projection of x2 in the kernel feature space\n#'\n#' @export\n#' @author Meiwen Jia, \\email{meiwen_jia@psych.mpg.de}\n#' @references Vaerenbergh, S. V. (2010). Kernel methods for nonlinear identification, equalization and separation of signals. Universidad de Cantabria.\n#'\n#' @examples\n#' set.seed(111)\n#' N <- 1000\n#' x <- runif(N) # latent signal\n#' r1 <- runif(N);  r2 <- runif(N)# random (helper) variables\n#' x1 <- cbind(tan(r1-x)+0.1*r1, r1+3*x-1/10*(sin(3*x)))\n#' x2 <- cbind(x - 2*(1-exp(-r2))/(1+exp(-r2)), r2*x, tan(r2+x))\n#' cat(\"The correlation is \", kerncca(x1, x2)$cor, \"\\n\")\n#'\nkerncca <- function(x1,\n                    x2,\n                    ktyp1 = \"rbfdot\",\n                    ktyp2 = \"rbfdot\",\n                    kpar1 = list(sigma=0.01),\n                    kpar2 = list(sigma=0.01),\n                    reg = 1e-5, # regularization\n                    nlatent =2 ,\n                    ...){\n  # An incomplete cholesky decomposition calculates Z where K= ZZ' K being the kernel matrix.\n  G1 <- kernlab::inchol(x1, kernel = ktyp1, kpar = kpar1)\n                        #, ...)\n  G2 <- kernlab::inchol(x2, kernel = ktyp2, kpar = kpar2)\n  #, ...)\n  # do column centering\n  # important! ignoring will cause problem\n  G1 <- scale(G1, center = T, scale = F)\n  G2 <- scale(G2, center = T, scale = F)\n  #   # option1 faster!\n  #   # ones and zeros\n  #   N1 <- ncol(G1)\n  #   N2 <- ncol(G2)\n  #   Z11 <- matrix(0, N1, N1)\n  #   Z22 <- matrix(0, N2, N2)\n  #   Z12 <- matrix(0, N1, N2)\n  #   I11 <- diag(N1)\n  #   I22 <- diag(N2)\n  #\n  #   # simplified Hardoon\n  #   R <- rbind(cbind(Z11, t(G1)%*%G2),\n  #              cbind(t(G2)%*%G1, Z22))\n  #   D <-rbind(cbind(t(G1)%*%G1+reg*I11,Z12),\n  #             cbind(t(Z12), t(G2)%*%G2+reg*I22));\n  #\n  #   # solve generalized eigenvalue problem\n  #   eig.res <- geigen::geigen(R, D)\n  #   vecs <- eig.res$vectors\n  #   vals <- eig.res$values\n  #   alpha <- vecs[, which.max(vals), drop = F]\n  #   alpha <- alpha/norm(alpha, \"1\")\n  #   # the coefficient is the maximum eigenvalues\n  #   beta <- max(vals)\n  #\n  #   # expansion coefficients\n  #   alpha1 <- matrix(alpha[1:N1], ncol=1, byrow = F);\n  #   alpha2 <- matrix(alpha[N1+(1:N2)], ncol=1, byrow = F);\n  #\n  #   # estimates of latent variable\n  #   y1 <- G1%*%alpha1\n  #   y2 <- G2%*%alpha2\n  #\n  #\n  #   return(list(cor = sort(vals, decreasing = T), latent1 = y1, latent2 = y2, G1 = G1, G2 = G2))\n  # option2\n  G1G2_cca <- cancor(G1, G2)\n  alpha <- matrix(rbind(G1G2_cca$xcoef[,1:nlatent], G1G2_cca$ycoef[,1:nlatent]),ncol = nlatent)\n                  #, ncol = 1)\n  alpha <- alpha/norm(alpha, \"1\")\n  y1 <- G1%*%alpha[1:ncol(G1),1:nlatent]\n  y2 <- G2%*%alpha[ncol(G1)+(1:ncol(G2)),1:nlatent]\n  return(list(cor = G1G2_cca$cor, latent1 = y1, latent2 = y2, G1 = G1, G2 = G2))\n}\n",
    "created" : 1484833283165.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2984627313",
    "id" : "7EFC5CA7",
    "lastKnownWriteTime" : 1484909512,
    "last_content_update" : 1484909932354,
    "path" : "~/My_project/tSNEcca/kerncca.R",
    "project_path" : "kerncca.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}